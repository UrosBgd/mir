<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1487511441809">{:repl-history {:ide [], :local [&quot;(load-encodings)&quot; &quot;(def z1\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (empty? i) cnt\n              :t (recur (rest i)(if (and (&gt; (first i) 0) (&lt; (second i) 0) (inc cnt))))))))&quot; &quot;(def z1\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (empty? i) cnt\n              :t (recur (rest i)(if (and (&gt; (first i) 0) (&lt; (second i) 0) (inc cnt) nil)))))))&quot; &quot;(if 1)&quot; &quot;(if nil \&quot;logical true\&quot; \&quot;logical false\&quot;)&quot; &quot;(if nil \&quot;logical true\&quot;)&quot; &quot;(if (and (&gt; 1 0) (&lt; 2 3)) \&quot;logical true\&quot;)&quot; &quot;(if (and (&gt; (first [1 2 3]) 0) (&lt; (second [1 2 3]) 3)) \&quot;logical true\&quot;)&quot; &quot;(def z1\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (empty? i) cnt\n              :t (recur (rest i)(if (and (&gt; (first i) 0) (&lt; (second i) 0)) (inc cnt)))))))&quot; &quot;(z1 [1 -1])&quot; &quot;(z1 [1 -1 1 -1])&quot; &quot;(def z2\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (empty? i) cnt\n              :t (recur (rest i)(if (&gt; (first i) 0) (inc cnt)))))))&quot; &quot;(z2 [1 -1 1 -1])&quot; &quot;(z2 [1 -1])&quot; &quot;(def z3\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (empty? i) cnt\n              :t (recur (rest i)(if (&gt; (first i) 0) (inc cnt) cnt))))))&quot; &quot;(z3 [1 -1])&quot; &quot;(def z\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (empty? i) cnt\n              :t (recur (rest i)(if (and (&gt; (first i) 0) (&lt; (second i) 0)) (inc cnt) cnt))))))&quot; &quot;(z [1 -1])&quot; &quot;(z [1 -1 1 1 1])&quot; &quot;(z [1 -1 1])&quot; &quot;(def zz\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (or (empty? i) (empty? (second i))) cnt\n              :t (recur (rest i)(if (and (&gt; (first i) 0) (&lt; (second i) 0)) (inc cnt) cnt))))))&quot; &quot;(zz [1 -1])&quot; &quot;(second [1 2 3])&quot; &quot;(def zzz\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (or (empty? i) (empty? (rest i))) cnt\n              :t (recur (rest i)(if (and (&gt; (first i) 0) (&lt; (second i) 0)) (inc cnt) cnt))))))&quot; &quot;(zzz [1 -1])&quot; &quot;(zzz [1 -1 1 -2 -3])&quot; &quot;(zzz [1 -1 1 -2 3 -1])&quot; &quot;(defn isCrossPoint [a b] ((if (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (!= b 0)))))&quot; &quot;(defn isCrossPoint [a b] ((if (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0)))))&quot; &quot;(defn isCrossPoint [a b] ((if (or (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0))))))&quot; &quot;(defn isCrossPoint [a b] ((if (or (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0)))) true))&quot; &quot;(isCrossPoint [[1] [-1]])&quot; &quot;(isCrossPoint [1] [-1])&quot; &quot;(defn isCrossPoint [a, b] ((if (or (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0))) true)))&quot; &quot;(isCrossPoint [1 -1])&quot; &quot;(isCrossPoint 1 -1])&quot; &quot;(defn isCrossPoint [a b] ((if (or (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0))) true)))&quot; &quot;(if (= 1 1) true)&quot; &quot;(defn isCrossPoint [a b] (if (or (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0))) true))&quot; &quot;(isCrossPoint 1 -1)&quot; &quot;(defn isCrossPoint [a b] (if (or (and (&gt; a 0) (&lt; b 0)) (and (&lt; a 0) (&gt; b 0)) (and (= a 0) (not= b 0))) true false))&quot; &quot;(isCrossPoint -1 -1)&quot; &quot;(def zzz\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (or (empty? i) (empty? (rest i))) cnt\n              :t (recur (rest i)(if (isCrossPoint (first i) (second i)) (inc cnt) cnt))))))&quot; &quot;(zzz [1 -1 1 -2 3 0])&quot; &quot;(def zzz\n  (fn [lst]\n    (loop [i lst cnt 0]\n      (cond (or (empty? i) (empty? (rest i))) cnt\n              (recur (rest i)(if (isCrossPoint (first i) (second i)) (inc cnt) cnt))))))&quot; &quot;(cond (= 1 1) (inc 1) 3)&quot; &quot;(cond (= 1 1) (inc 1) (+ 3 2))&quot; &quot;(cond (= 1 1) 3 2)&quot; &quot;(cond (= 1 1) 3 :t 2)&quot; &quot;(cond (= 1 1) (inc 1) :t (+ 3 2))&quot; &quot;(cond (= 1 2) (inc 1) :t (+ 3 2))&quot; &quot;(doseq [s (map #(str %1 %2) [1 2 3] [0 1 1])]\n  (println s))&quot; &quot;(defn pow [b e] (Math/pow b e))&quot; &quot;(pow 2 2)&quot; &quot;(pow 2 3)&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])]\n  (pow s 2))&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])]\n  (pow s 2) (print s))&quot; &quot;(doseq [s (map (pow #(- %1 %2) 2) [1 2 3] [0 1 1])]\n  (println s))&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])]\n  (println s))&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])]\n  (sum s))&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])]\n  (print (sum s)))&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])]\n  (print (+ s 1)))&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])])&quot; &quot;(doseq [s (map #(- %1 %2) [1 2 3] [0 1 1])] s)&quot; &quot;(map pow (map #(- %1 %2) [1 2 3] [0 1 1]) 2)&quot; &quot;(map pow [(map #(- %1 %2) [1 2 3] [0 1 1])] 2)&quot; &quot;(pow [2 2] 2)&quot; &quot;([(map #(- %1 %2) [1 2 3] [0 1 1])])&quot; &quot;(map (pow #(- %1 %2) 2) [1 2 3] [0 1 1])&quot; &quot;(map (* #(- %1 %2) #(- %1 %2)) [1 2 3] [0 1 1])&quot; &quot;(map #(- %1 %2) [1 2 3] [0 1 1])&quot; &quot;[1 2 3]&quot; &quot;(sum (map - [1 2 3] [0 1 1]))&quot; &quot;(apply sum (map - [1 2 3] [0 1 1]))&quot; &quot;(sum (vec (map - [1 2 3] [0 1 1])))&quot; &quot;(vec (map - [1 2 3] [0 1 1]))&quot; &quot;(sum [1 2 3])&quot; &quot;(+ [1 2 3])&quot; &quot;(+ 2 3)&quot; &quot;(apply + (vec (map - [1 2 3] [0 1 1])))&quot; &quot;( + (map - [1 2 3] [0 1 1]))&quot; &quot;(apply + (map pow (map - [1 2 3] [0 1 1]) 2))&quot; &quot;(apply + (apply map pow (map - [1 2 3] [0 1 1]) 2))&quot; &quot;(apply + (map - [1 2 3] [0 1 1]) #(pow % 2))&quot; &quot;(apply + (map #(pow % 2) - [1 2 3] [0 1 1]))&quot; &quot;(apply + (map #(pow % 2) [1 2 3] [0 1 1]))&quot; &quot;(map - [1 2 3] [0 1 1])&quot; &quot;(apply map #(pow % 2)  (1 2 3))&quot; &quot;(map #(apply pow % 2)  (1 2 3))&quot; &quot;(map #(pow % 2) (vec (1 2 3)))&quot; &quot;(map #(pow % 2) [1 2 3])&quot; &quot;(apply + (map - [1 2 3] [0 1 1]))&quot; &quot;(map #(pow % 2) (1 2 3))&quot; &quot;(+ (mapv - [1 2 3] [0 1 1]))&quot; &quot;(apply + (mapv - [1 2 3] [0 1 1]))&quot; &quot;(mapv - [1 2 3] [0 1 1])&quot; &quot;(map #(pow % 2) (mapv - [1 2 3] [0 1 1]))&quot; &quot;(mapv #(pow % 2) (mapv - [1 2 3] [0 1 1]))&quot; &quot;(apply + (mapv #(pow % 2) (mapv - [1 2 3] [0 1 1])))&quot; &quot;(defn extractFeature [thisMagnitudeSpectrum previousMagnitudeSpectrum] (\napply + (mapv #(pow % 2) (mapv - thisMagnitudeSpectrum previousMagnitudeSpectrum))\n))&quot; &quot;(extractFeature [1 2 3] [0 1 0])&quot;], :remote []}}</component>
</project>